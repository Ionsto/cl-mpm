(defpackage :cl-mpm/fastmath
  (:use :cl)
  (:import-from
    :magicl tref .+ .-)
  (:export
   #:fast-add
   #:fast-fmacc
   #:mult
   #:det
   #:dot
   #:norm
    ))

(declaim (optimize (debug 0) (safety 0) (speed 3)))
(in-package :cl-mpm/fastmath)

(pushnew :sb-simd *features*)
(eval-when
    (:compile-toplevel)
  (pushnew :sb-simd *features*)
  #+:sb-simd (require 'sb-simd)
  )

#+:sb-simd
(progn
  ;(require 'sb-simd)
  (declaim
   (inline simd-accumulate)
   (ftype (function ((simple-array double-float)
                     (simple-array double-float)) (values)) simd-accumulate))
  (defun simd-accumulate (a b)
    ;; (declare (type (simple-array double-float 3) a b))
    (declare (type sb-simd:f64vec a b))
    (setf (sb-simd-avx:f64.2-aref a 0)
          (sb-simd-avx:f64.2+
           (sb-simd-avx:f64.2-aref a 0)
           (sb-simd-avx:f64.2-aref b 0)
           ))
    (incf (aref a 2) (aref b 2))
    ;; (loop for i from 0 to 2
    ;;       do (incf (aref a i) (aref b i)))
    (values))

  (declaim
   (inline simd-fmacc)
   (ftype (function ((simple-array double-float) (simple-array double-float) double-float) (values)) simd-fmacc))
  (defun simd-fmacc (a b scale)
    (declare (type sb-simd:f64vec a b)
             (type double-float scale))
    (setf (sb-simd-avx:f64.2-aref a 0)
          (sb-simd-avx:f64.2+
           (sb-simd-avx:f64.2-aref a 0)
           (sb-simd-avx:f64.2*
            (sb-simd-avx:f64.2-aref b 0)
            (sb-simd-avx:f64.2 scale))
           ))
    (incf (aref a 2) (* scale (aref b 2)))
                                        ;(loop for i from 0 to 2
                                        ;      do (incf (aref a i) (* scale (aref b i))))
    (values))
  (declaim
   (inline simd-add)
   (ftype (function (magicl:matrix/double-float magicl:matrix/double-float) (values)) simd-add))
  (defun simd-add (a b)
    (simd-accumulate (magicl::matrix/double-float-storage a)
                     (magicl::matrix/double-float-storage b))
    (values)))

;; (declaim
;;  (inline mult)
;;  (ftype (function (magicl:matrix/double-float
;;                    magicl:matrix/double-float
;;                    magicl:matrix/double-float) (values)
;;                   ) mult))
;; (defun mult (a b res)
;;   (declare (type magicl:matrix/double-float a b res))
;;   (let ((a-s (magicl::matrix/double-float-storage a))
;;         (b-s (magicl::matrix/double-float-storage b))
;;         (res-s (magicl::matrix/double-float-storage res))
;;         )
;;     (declare (type (simple-array double-float) a-s b-s res-s))
;;     (loop for i from 0 to 2
;;           do (loop for j from 0 to 1
;;                    do (incf (aref res-s i) (* (aref a-s (+ j (* 2 i)))
;;                                               (aref b-s j)))))))

;; (declaim (inline det)
;;          (ftype (function (magicl:matrix/double-float) (values double-float)) det)
;;          )
;; (defun det (x)
;;   (let ((x-a (magicl::matrix/double-float-storage x)))
;;     (declare (type (simple-array double-float) x-a))
;;     (values (- (* (aref x-a 0) (aref x-a 3))
;;                (* (aref x-a 1) (aref x-a 2))))))

(declaim
 (inline fast-fmacc-array)
 (ftype (function ((simple-array double-float)
                   (simple-array double-float)
                   double-float) (values)) fast-fmacc))
(defun fast-fmacc-array (a b d)
  #+:sb-simd (simd-fmacc a
                         b
                         d)
  #-:sb-simd (setf a (aops:reduce #'+ a (aops:each (lambda (x) (* x d)) b))))

(declaim
 (inline fast-fmacc)
 (ftype (function (magicl:matrix/double-float
                   magicl:matrix/double-float
                   double-float) (values)) fast-fmacc))
(defun fast-fmacc (a b d)
  #+:sb-simd (simd-fmacc (magicl::matrix/double-float-storage a)
                          (magicl::matrix/double-float-storage b)
                          d)
  #-:sb-simd (magicl.simd::.+-simd a (magicl:scale b d) a)
  ;; (magicl.simd::.+-simd a (magicl:scale b d) a)
  )

(declaim
   (inline fast-add)
   (ftype (function (magicl:matrix/double-float magicl:matrix/double-float) (values)) fast-add))
(defun fast-add (a b)
  #+:sb-simd (simd-add a b)
  #-:sb-simd (magicl:.+ a b a)
  )

(declaim
 (inline simd-any+)
 (ftype (function ((simple-array double-float)
                           (simple-array double-float)
                           (simple-array double-float))
                          (values)) simd-any+))
(defun simd-any+ (a b target)
  (declare (optimize (speed 3) (debug 0) (safety 0)))
  ;; (declare ((simple-array double-float (*)) a b target))
  (let ((offset 0))
    (declare (type sb-simd:f64vec a b target)
             (fixnum offset))
    (multiple-value-bind (iter remain) (floor (length a) 2)
      (declare (fixnum iter remain))
      (loop for i fixnum from 0 by 2
            repeat iter
            do
               (setf (sb-simd-avx:f64.2-aref target offset)
                     (sb-simd-avx:f64.2+
                      (sb-simd-avx:f64.2-aref a offset)
                      (sb-simd-avx:f64.2-aref b offset))))
      ;; (dotimes (i iter)
      ;;   (setf (sb-simd-avx:f64.2-aref target offset)
      ;;         (sb-simd-avx:f64.2+
      ;;          (sb-simd-avx:f64.2-aref a offset)
      ;;          (sb-simd-avx:f64.2-aref b offset)))
      ;;   (incf offset 2)
      ;;   )
      (unless (eq remain 0)
        (dotimes (i remain)
          (setf (aref target offset)
                (+ (aref a offset) (aref b offset)))
          (incf offset 1))
        )
      ))
  target)

(defun @-m-v (matrix vector result-vector)
  "Multiply a 3x3 matrix with a 3x1 vector to calculate a 3x1 vector in place"
  (declare (magicl:matrix/double-float matrix vector result-vector)
           (optimize (speed 3) (safety 0) (debug 0)))
  (let ((a (magicl::matrix/double-float-storage matrix))
        (b (magicl::matrix/double-float-storage vector))
        (c (magicl::matrix/double-float-storage result-vector))
        )
    (declare ((simple-array double-float (9)) a)
             ((simple-array double-float (3)) b c))
    (flet ((tref (m x y)
             (aref m (+ x (* 3 y)))))
      (loop for i fixnum from 0 below 3
            do
               (setf
                (aref c i)
                (+
                 (* (aref b 0) (tref a i 0))
                 (* (aref b 1) (tref a i 1))
                 (* (aref b 2) (tref a i 2))
                 )
                )
            )))
  result-vector)

(declaim
 (inline @-stretch-vec)
 (ftype (function (magicl:matrix/double-float magicl:matrix/double-float magicl:matrix/double-float)
                          magicl:matrix/double-float) @-stretch-vec))
;; (defun @-stretch-vec (matrix vector result-vector)
;;   "Multiply a 3x9 matrix with a 3x1 vector to calculate a 3x1 vector in place"
;;   (declare (magicl:matrix/double-float matrix vector result-vector)
;;            (optimize (speed 3) (safety 0) (debug 0)))
;;   (let ((a (magicl::matrix/double-float-storage matrix))
;;         (b (magicl::matrix/double-float-storage vector))
;;         (c (magicl::matrix/double-float-storage result-vector))
;;         )
;;     (declare ((simple-array double-float (27)) a)
;;              ((simple-array double-float (9)) c)
;;              ((simple-array double-float (3)) b)
;;              )
;;     (flet ((tref (m x y)
;;              (aref m (+ (* 9 x)  y))))
;;       (loop for i fixnum from 0 below 9
;;             do
;;                (setf (aref c i) 0d0)
;;                (loop for j fixnum from 0 below 3
;;                      do (incf (aref c i) (the double-float (* (aref b j) (tref a j i)))))
;;             )))
;;   result-vector)
(defun @-stretch-vec (matrix vector result-vector)
  "Multiply a 9x3 matrix with a 3x1 vector to calculate a 9x1 vector in place - SIMD implementation"
  (declare (magicl:matrix/double-float matrix vector result-vector)
           (optimize (speed 3) (safety 0) (debug 0)))
  (let ((a (magicl::matrix/double-float-storage matrix))
        (b (magicl::matrix/double-float-storage vector))
        (c (magicl::matrix/double-float-storage result-vector))
        )
    (declare ((simple-array double-float (27)) a)
             ((simple-array double-float (3)) b)
             ((simple-array double-float (9)) c)
             )
    (macrolet ((simd-component (i)
                 (declare (fixnum i))
                 `(setf
                   (sb-simd-avx:f64.4-aref c ,(the fixnum (* 4 i)))
                   (sb-simd-avx:f64.4+
                    (sb-simd-avx:f64.4*
                     (sb-simd-avx:f64.4-aref a ,(the fixnum (+ (* i 4) (* 9 0))))
                     (aref b 0))
                    (sb-simd-avx:f64.4*
                     (sb-simd-avx:f64.4-aref a ,(the fixnum (+ (* i 4) (* 9 1))))
                     (aref b 1))
                    (sb-simd-avx:f64.4*
                     (sb-simd-avx:f64.4-aref a ,(the fixnum (+ (* i 4) (* 9 2))))
                     (aref b 2))))
                 ))
      (simd-component 0)
      (simd-component 1)
      (setf
       (aref c 8)
       (+
        (* (aref a (+ 8 0)) (aref b 0))
        (* (aref a (+ 8 9)) (aref b 1))
        (* (aref a (+ 8 18)) (aref b 2))))
      )
    ;; (flet ((tref (m x y)
    ;;          (aref m (+ (* 9 x)  y))))
    ;;   (loop for i fixnum from 0 below 9
    ;;         do
    ;;            (setf (aref c i) 0d0)
    ;;            (loop for j fixnum from 0 below 3
    ;;                  do (incf (aref c i) (the double-float (* (aref b j) (tref a j i)))))
    ;;         ))
    )
  result-vector)

(declaim
 (inline @-dsvp-vec)
 (ftype (function (magicl:matrix/double-float magicl:matrix/double-float double-float magicl:matrix/double-float)
                  magicl:matrix/double-float) @-dsvp-vec))
(defun @-dsvp-vec (matrix vector scale result-vector)
  "Multiply a 3x9 matrix with a 3x1 vector to calculate a 3x1 vector in place"
  (declare (magicl:matrix/double-float matrix vector result-vector)
           (double-float scale)
           (optimize (speed 3) (safety 0) (debug 0)))
  (let ((a (magicl::matrix/double-float-storage matrix))
        (b (magicl::matrix/double-float-storage vector))
        (c (magicl::matrix/double-float-storage result-vector))
        )
    (declare ((simple-array double-float (18)) a)
             ((simple-array double-float (3)) c)
             ((simple-array double-float (6)) b)
             )
    (flet ((tref (m x y)
             (aref m (+ (* 6 x) y))))
      (loop for i fixnum from 0 below 3
            do
               (setf (aref c i) 0d0)
               (loop for j fixnum from 0 below 6
                     do (incf (aref c i) (the double-float (* (aref b j) (tref a i j) scale))))
            )))
  result-vector)


;; (declaim
;;  (inline fast-.+)
;;  (ftype (function (magicl:matrix/double-float magicl:matrix/double-float) magicl:matrix/double-float) fast-.+))
;; (defun fast-.+ (a b)
;;   (declare (optimize (speed 3) (space 0)))
;;   (let ((res (cl-mpm/utils::deep-copy a)))
;;     (declare (magicl:matrix/double-float a b res))
;;     (simd-any+ (magicl::matrix/double-float-storage a)
;;                (magicl::matrix/double-float-storage b)
;;                (magicl::matrix/double-float-storage res))
;;     res))

(declaim
 (inline fast-.+)
 (ftype (function (magicl:matrix/double-float magicl:matrix/double-float &optional magicl:matrix/double-float) magicl:matrix/double-float) fast-.+))
(defun fast-.+ (a b &optional res)
  (declare (optimize (speed 3) (space 0)))
  (let ((res (if res
                 res
                 (cl-mpm/utils::deep-copy a))))
    (declare (magicl:matrix/double-float a b res))
    (simd-any+ (magicl::matrix/double-float-storage a)
               (magicl::matrix/double-float-storage b)
               (magicl::matrix/double-float-storage res))
    res))

(macrolet ((def-fast-.+-type (name length)
             `(progn
                (declaim
                 (inline fast-.+-vector)
                 (ftype (function (magicl:matrix/double-float magicl:matrix/double-float &optional magicl:matrix/double-float) magicl:matrix/double-float) fast-.+-vector))
                (defun ,name (a b &optional res)
                  (declare (optimize (speed 3) (space 0)))
                  (let ((res (if res
                                 res
                                 (cl-mpm/utils::deep-copy a))))
                    (declare (magicl:matrix/double-float a b res))
                    (simd-any+ (the (simple-array double-float (,length)) (magicl::matrix/double-float-storage a))
                               (the (simple-array double-float (,length)) (magicl::matrix/double-float-storage b))
                               (the (simple-array double-float (,length)) (magicl::matrix/double-float-storage res)))
                    res)))))
  )
;; (declaim
;;  (inline fast-.+-vector)
;;  (ftype (function (magicl:matrix/double-float magicl:matrix/double-float &optional magicl:matrix/double-float) magicl:matrix/double-float) fast-.+-vector))
;; (defun fast-.+-vector (a b &optional res)
;;   (declare (optimize (speed 3) (space 0)))
;;   (let ((res (if res
;;                  res
;;                  (cl-mpm/utils::deep-copy a))))
;;     (declare (magicl:matrix/double-float a b res))
;;     (simd-any+ (the (simple-array double-float (3)) (magicl::matrix/double-float-storage a))
;;                (the (simple-array double-float (3)) (magicl::matrix/double-float-storage b))
;;                (the (simple-array double-float (3)) (magicl::matrix/double-float-storage res)))
;;     res))




(declaim
 (inline fast-scale)
 (ftype (function (magicl:matrix/double-float double-float) magicl:matrix/double-float) fast-scale))
(defun fast-scale (m scale)
  (let ((m-s (magicl::matrix/double-float-storage m)))
    (loop for i fixnum from 0 below (length m-s)
          do (setf (aref m-s i) (* (aref m-s i) scale)))) m)
(declaim
 (inline fast-zero)
 (ftype (function (magicl:matrix/double-float) magicl:matrix/double-float) fast-zero))
(defun fast-zero (m)
  (let ((m-s (magicl::matrix/double-float-storage m)))
    (loop for i fixnum from 0 below (length m-s)
          do (setf (aref m-s i) 0d0))) m)

;; (declaim
;;  (inline fast-.+)
;;  (ftype (function (magicl:matrix/double-float magicl:matrix/double-float) (magicl:matrix/double-float)) fast-.+))
;; (defun fast-.+ (a b)
;;   (let ((res ))
;;     )
;;   )
;; (declaim
;;  (inline fast-.+)
;;  (ftype (function (magicl:matrix/double-float magicl:matrix/double-float magicl:matrix/double-float) (magicl:matrix/double-float)) fast-.+))
;; (defun fast-.+ (a b res)
;;   )


(declaim (inline voigt-tensor-reduce-lisp)
         (ftype (function (magicl:matrix/double-float) (values double-float)) voigt-tensor-reduce-lisp))
(let ((second-invar (magicl:from-array (make-array 6 :initial-contents '(1d0 1d0 1d0 0.5d0 0.5d0 0.5d0)) '(6 1) :type 'double-float :layout :column-major)))
  (defun voigt-tensor-reduce-lisp (a)
     (values (magicl::sum (magicl.simd::.*-simd a a second-invar)))))

(declaim (inline voigt-tensor-reduce-simd)
         (ftype (function (magicl:matrix/double-float) double-float) voigt-tensor-reduce-simd))
(defun voigt-tensor-reduce-simd (a)
  "Calculate the product A_{ij}A_{ij}"
  (let ((arr (magicl::matrix/double-float-storage a)))
    (declare ((simple-array double-float) arr))
    (+
     (* (aref arr 0) (aref arr 0))
     (* (aref arr 1) (aref arr 1))
     (* (aref arr 2) (aref arr 2))
     (* (aref arr 3) (aref arr 3) 0.5d0)
     (* (aref arr 4) (aref arr 4) 0.5d0)
     (* (aref arr 5) (aref arr 5) 0.5d0)
     )))

(defun voigt-tensor-reduce (a)
  #+:sb-simd (voigt-tensor-reduce-simd a)
  #-:sb-simd (voigt-tensor-reduce-lisp a)
  )

;; (declaim (inline flat-tensor-reduce-simd)
;;          (ftype (function (magicl:matrix/double-float) double-float) flat-tensor-reduce-simd))
;; (defun flat-tensor-reduce-simd (a)
;;   "Calculate the product A_{ij}A_{ij} but without voigt notation"
;;   (let ((arr (magicl::matrix/double-float-storage a)))
;;     (declare ((simple-array double-float) arr))
;;     (+
;;      (* (aref arr 0) (aref arr 0))
;;      (* (aref arr 1) (aref arr 1))
;;      (* (aref arr 2) (aref arr 2) 0.5d0))))

;; (declaim (inline stretch-to-sym)
;;          (ftype (function (magicl:matrix/double-float magicl:matrix/double-float) (values)) stretch-to-sym))
;; (defun stretch-to-sym (stretch result)
;;   ;; (unless result
;;   ;;   (setf result (cl-mpm/utils:voigt-zeros)))
;;   (progn
;;     (declaim (magicl:matrix/double-float result))

;;     (let ((res (matrix-to)(magicl:.+ stretch (magicl:transpose stretch)))))
;;     ;; (loop for i from 0 below 3
;;     ;;       do
;;     ;;          (setf (magicl:tref result  i 0)
;;     ;;                (magicl:tref stretch i 0)))
;;     (setf (magicl:tref result  0 0)
;;           (magicl:tref stretch 0 0))

;;     (setf (magicl:tref result  1 0)
;;           (magicl:tref stretch 1 1))
;;     ;;Since off diagonal components get halved, then voigt doubles them this is net 1d0
;;     (setf (magicl:tref result 5 0)
;;           (* 1d0 (+ (the double-float (magicl:tref stretch 0 1))
;;                     (the double-float (magicl:tref stretch 1 0)))))
;;     )
;;   (values))


;; (defun mult-transpose-accumulate (a b scale res)
;;   "(incf res (scale! (@ (tranpose a) b) scale))"
;;   (declare (type magicl:matrix/double-float a b res)
;;            (type double-float scale))
;;   (declare (optimize (safety 3)))
;;   (let (
;;         ;; (a-s (magicl::matrix/double-float-storage a))
;;         ;; (b-s (magicl::matrix/double-float-storage b))
;;         ;; (res-s (magicl::matrix/double-float-storage res))
;;         )
;;     (loop for i from 0 to 1
;;           do (loop for j from 0 to 2
;;                    do (incf (the double-float (magicl:tref res i 0)) (* (the double-float (magicl:tref a j i))
;;                                                                         (the double-float (magicl:tref b j 0)) scale))))))

(defun dot (a b)
  (the double-float (magicl::sum (magicl.simd::.*-simd a b))))

(defun mag-squared (a)
  "Calculate the magnitude - 2-norm"
  (dot a a))

(defun mag (a)
  "Calculate the magnitude - 2-norm"
  (sqrt (mag-squared a)))

(defun norm (a)
  "Normalise a vector"
  (let ((m (mag-squared a)))
    (declare (double-float m))
    (if (> m 0d0)
      (magicl::scale a (/ 1d0 (sqrt m)))
      m)))

(defun cross-product (a b)
  "Calculate the cross product of column vectors a and b, returning a new vector"
  (let ((as (magicl::matrix/double-float-storage a))
        (bs (magicl::matrix/double-float-storage b))
        )
    (cl-mpm/utils:vector-from-list (list
                                    (- (* (aref as 1) (aref bs 2)) (* (aref as 2) (aref bs 1)))
                                    (- (* (aref as 2) (aref bs 0)) (* (aref as 0) (aref bs 2)))
                                    (- (* (aref as 0) (aref bs 1)) (* (aref as 1) (aref bs 0)))))))
